<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intervalos</title>
</head>
<body>
    <h1>Intervalos</h1>
    <div></div>
    <script>
        const tempoInicio = Date.now();
        let n = 0;

        // vamos criar uma função anonima para ser executada depois de um perido de tempo
        setTimeout(function(){
            console.log("timeout depois de 2000ms");
            const tempoFinal = Date.now();
            console.log(tempoFinal - tempoInicio); // 6175 = codigo executado depois de mais de 6 segundos
        }, 2000); // será executada em 2s

        // vamos ver o que acontece se tivermos depois do (setTimeout), um codigo que demanda um processamento alto? Vamos criar um loop pouco perfomatico para gerar um codigo que demore de ser executado.
        // Como podemos ver o codigo do setTimeout() apesar de ter sido agendado para ser executado em 2000ms, foi executado em 6175, pois tinhamos um outro codigo sendo executado.
        let str = "";
        var d = document.querySelector("div");
        for(let i = 0; i < 1000; i++){
            str += `i: ${i}-- `;
            d.textContent += str;
        }

        // vamos criar uma função que será executada de tempos em tempos
        // setInterval(function(){
            // console.log("interval n: " + n++);
            // if(n > 15){ 
            // }
        // }, 2000);
        // para limpar o intervalo depois de 15 segundos, usamos o metood clearInterval
        // porem para termos acesso ao (setInterval)  precisamos da uma id a ele

        const interval = setInterval(function(){
            console.log("interval n: " + n++);
            if(n > 5){ 
                clearInterval(interval);
            }
        }, 2000);


    </script>
</body>
</html>